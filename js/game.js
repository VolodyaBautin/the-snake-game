const canvas = document.getElementById('game')
const ctx = canvas.getContext('2d') // Игра будет в формате 2д. Контекст игры

const ground = new Image() // Image - специальный класс в js для работы с картинками. Вставляем картинку для игрового поля
ground.src = 'img/ground.png' // Пока только вызвана картинка, но она не будет видна, так как ещё не нарисована.

const foodImg = new Image() // Картинка еды
foodImg.src = 'img/food.png'

let box = 32 // Переменная которая отвечает за ширину или высоту одного квадратика в игровом поле

let score = 0 // Эта переменная хранит общий счёт в игре

let food = {
  x: Math.floor(Math.random() * 17 + 1) * box, // Рандомная генерация числа од 1 до 17. 17 всего квадратиков в поле по горизонатали и умножает на ширину квадратика, таким образом присваива координату x
  y: Math.floor(Math.random() * 15 + 3) * box, // 15 квадратиков по вертикали, но прибавляем 3, чтобы минимум было смещение на квадратика вниз 
}
// Змейка будет изменяться, поэтому тут нужен массив данных, который сможет расти
let snake = []

// Указываем позицию змейки при запуске
snake[0] = {
  x: 9 * box,
  y: 10 * box
}

// Движение змейки с помощью обработчика событий:
document.addEventListener('keydown', direction)

let dir

function direction(event) {
  if (event.keyCode == 37 && dir != 'right') // Если нажали на стрелочку слева, то двигаемся влево. Также делаем так, что двигаться влево нельзя, если направление равно вправо.
    dir = 'left'
  else if (event.keyCode == 38 && dir != 'down') // Вверх
    dir = 'up'
  else if (event.keyCode == 39 && dir != 'left') // Cправа
    dir = 'right'
  else if (event.keyCode == 40 && dir != 'up') // Вниз
    dir = 'down'

}

// Ф-ция, которая будет останавливать игру, если змейка есть свой хвост
function eatTail(head, arr) {
  for (let i = 0; i < arr.length; i++) {
    if (head.x == arr[i].x && head.y == arr[i].y) {
      clearInterval(game)
    }
  }
}


// Ф-ция рисующая объекты внутри canvas
function drawGame() {
  ctx.drawImage(ground, 0, 0) // drawImage - это ф-ция которая отвечает за то, чтобы нарисовать изображение на определённых координатах по x и y. 0 по x и y находится в левом верхнем углу, т.е изображение будет рисоваться от туда. т.е изображение нарисуется на всю ширину и высоту canvas

  ctx.drawImage(foodImg, food.x, food.y) // Рисуем картинку еды

  for (let i = 0; i < snake.length; i++) {
    ctx.fillStyle = i == 0 ? 'green' : 'red' // Рисуем змейку, только не с помощью картинки. Эта строка - Фон змеи. Первый элемент зелённый, остальные красные
    ctx.fillRect(snake[i].x, snake[i].y, box, box) // Таким образом по центру рисуем змею, с координатами исходя из длины змеи. Первый элемент змеи это координаты по центрку
  }

  ctx.fillStyle = 'white' // Рисуем текст сверху (Счётчик очков)
  ctx.font = '40px Arial'
  ctx.fillText(score, box * 2.5, box * 1.6)

  // Рисуем передвижение самой змейки
  // Назначаем в переменную координаты змейки
  let snakeX = snake[0].x
  let snakeY = snake[0].y

  // Если координаты головы змейки, совпадают с координатами еды, то счётчик увеличивается, создаётся новое расположение еды
  if (snakeX == food.x && snakeY == food.y) {
    score++
    food = {
      x: Math.floor(Math.random() * 17 + 1) * box,
      y: Math.floor(Math.random() * 15 + 3) * box,
    }
  } else {
    // Удаляем последний элемент в массиве, для того чтобы змейка постоянно не росла
    snake.pop()
  }

  // Если змейка выходит за пределы зоны, то интервла очищается и игра останавливается
  if (snakeX < box || snakeX > box * 17 || snakeY < box * 3 || snakeY > box * 17) {
    clearInterval(game)
  }

  if (dir == 'left') snakeX -= box // Если нажали кнопку влево, то координаты уменьшаются (т.е передвигаются влево)
  if (dir == 'right') snakeX += box // Если нажали кнопку вправо, то координаты увеличиваются (т.е передвигаются вправо)
  if (dir == 'up') snakeY -= box
  if (dir == 'down') snakeY += box

  // Создаём новую голову (указывая новые координаты), так как змейка или съела еду, и таким образом конец не был обрезан, или продолжается движение и последний элемент удаляется и появляется новый.
  let newHead = {
    x: snakeX,
    y: snakeY
  }


  eatTail(newHead, snake) // Вызываем ф-цию, которая отвечает за остановку игры, при поедании своего хвоста



  snake.unshift(newHead) // Помещаем новые координаты головы в начало массива

}

let game = setInterval(drawGame, 125) // Ф-ия drawgame будет вызываться каждые 100 мс, т.е присваеваме переменной вызов ф-ции каждые 100 мс
